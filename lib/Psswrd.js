const path = require('path')
const pkg = require('../package')
const fs = require('./utils/fs')
const Crypto = require('./utils/Crypto')
const Manifest = require('./models/Manifest')
const Secret = require('./models/Secret')
const Db = require('./utils/Db')
const {status, errors, keys, SYNC, DEFSALT} = require('./config/constants')
const {CONSTRUCTED, INITIATED, READY, OPERATIVE} = status

class Psswrd {

  constructor() {
    this.db = new Db
    this.rootdir = process.env.NODE_ENV === 'test'
        ? path.resolve(__dirname, '../tmp/.psswrd')
        : path.join(process.env.HOME, '.psswrd')
    this.db.init(path.join(this.rootdir, 'database'), SYNC)
    this.set(CONSTRUCTED)
  }

  init() {
    if (this.status === CONSTRUCTED && !this.initializingNow) {
      this.initializingNow = true
      return Promise.resolve()
          .then(() => fs.ensureDirAsync(this.rootdir))
          .then(() => {
            const readmePath = path.join(this.rootdir, 'README')
            if (!fs.existsSync(readmePath)) {
              return fs.ensureDirAsync(this.rootdir)
                  .then(() => {
                    return fs.writeFileAsync(path.join(this.rootdir, 'README'), `
This folder has been generated by psswrd v${pkg.version}.
It contains your secret's database. 
Be careful and don't touch anything!
`, 'utf-8')
                  })
            }
            else return Promise.resolve()
          })
          .then(() => {
            this.manifest = new Manifest(this.db)
            this.set(INITIATED)
            delete this.initializingNow
            return this.getEncryptedMasterKey()
          })
          .catch(err => delete this.initializingNow)
    } else if (this.status === INITIATED) {
      return this.getEncryptedMasterKey()
    } else {
      return Promise.resolve()
    }
  }

  getEncryptedMasterKey() {
    return this.db.get(keys.MASTERKEY)
        .then(key => {
          if (key) {
            this.encryptedMasterKey = key
            this.set(READY)
          }
          return Promise.resolve()
        })
  }

  gitInit(remoteRepo) {
    // TODO
    // associate the store to a remote repo
    return Promise.resolve()
        .then(() => {

          if (fs.existsSync(path.join(this.rootdir, '.git'))) {
            // repo exists
            return Promise.reject(errors.RepoExists)
          } else {
            // associate the remoteRepo

            return Promise.resolve()
          }
        })
  }

  set(status) {
    this.status = status
  }

  is(status) {
    return this.status === status
  }

  signup(password) {
    if (this.is(INITIATED)) {
      let masterKey
      return Crypto.getRandomString(64)
          .then(randomString => {
            masterKey = randomString
            return this.hashPassword(password)
          })
          .then(hashedPassword => Crypto.toAES(masterKey, hashedPassword))
          .then(encryptedMasterKey => {
            this.encryptedMasterKey = encryptedMasterKey
            return this.db.put(keys.MASTERKEY, encryptedMasterKey)
          })
          .then(() => this.manifest.init(masterKey))
          .then(() => Promise.resolve(this.set(OPERATIVE)))
    } else {
      return Promise.reject(errors.NotInitialized)
    }
  }

  login(password) {
    if (this.is(READY)) {
      return this.hashPassword(password)
          .then(hashedPassword => Crypto.fromAES(this.encryptedMasterKey, hashedPassword))
          .then(key => {
            this.manifest = new Manifest(this.db)
            return this.manifest.init(key)
          })
          .then(() => Promise.resolve(this.set(OPERATIVE)))
    } else {
      return Promise.reject(errors.NotReady)
    }
  }

  logout() {
    if (this.is(OPERATIVE)) {
      delete this.manifest
      this.set(CONSTRUCTED)
      return this.init()
    } else {
      return Promise.resolve()
    }
  }

  hashPassword(password) {
    return Crypto.deriveKey(password, DEFSALT)
  }

  ls(params) {
    return this.manifest.ls(params)
  }

  setSecret(options) {
    return this.manifest.setSecret(options)
  }

  onClose() {
    this.manifest.onClose()
    delete this.manifest
    delete this.db
  }

  isReady() {
    return this.is(READY)
  }

  isInitiated() {
    return this.is(INITIATED)
  }

  isOperative() {
    return this.is(OPERATIVE)
  }
}

module.exports = new Psswrd